((a ? b : c) + 1) ? d : e;




//(a ? b : c ? d : e);

//result = nested::func<type>(array[1][2], vec { x = 1, y = (5, "text").a }.b).a > (tuple[2].c + (flag ? (matrix[1][1] - array[2][3]).a : "default")).b ? "pass" : "fail";
//auto: result = (nested::func<type1, type2>(arg1, array[0][1] * (5 + 3)).a / vec { x = 1, y = (10, 20).b }.y) > (matrix[2][3] ? 15 : -5) ? "valid" : "invalid";
//str: response = (tuple[1].b == (nested::call(array[0][1] > 0 ? (5, 10).a : vec { x = 2 }.x) + func<type>("arg").a).c) ? "success" : "failure";

;// TODO:
// if 0 == 0 || false { }
// else if true { }
// else { }
// while true { }
// for x in array.skip(1) { }
// match name { "john" => {}, "doe" => {}, _ => {} }
// loadlib "file.dll" // load dll
// use LIB::This // include library
// use LIB::* // library with astrix includes
// use LIB::{a, b} // includes specific members
// #! alias // for compiler: shorthand for instantiation of class
// #! def NAME = VALUE // for compiler: define compile time constants
// #! def ADD(x, y) x + y // define function
// #! once NAME // for compiler if not defined, then define. For files
// #! ifndef NAME // spceific compile time if
// #! if ARGUMENT // if statement for compilers
// #! deprecated 
// #! allow WARNING_OR_ERROR
// #! warn WARNING_OR_ERROR
// #! error WARNING_OR_ERROR
// u0: add(u8: a, u8: b) -> "example" { }
// string: to_string() => "Obj [" + name.to_string() + "]";
// enum Files { File1 = 0 -> "1", File2 }
// class Color { }
// struct Pixel { }
