{
    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    i32: x = (5 + 3) * -(-2);
    value = (1, "test", true).b;
    auto: result = array[0][1] + matrix[2][3];
    point: vec = vec { x = 10, y = array[1][2] };
    str: message = func<type>("arg1", (nested[1][0], "test").a);
    bool: check = (x > 0 ? 1 : 2) == (tuple[0].c);
    i32: value = { x: i32 = 10; y = -x * 3; return y; };
    tuple: data = (3, 4, vec { a = 1, b = 2 }).c;
    x = -((5 + array[0][2]) * ~(tuple[1].b));
    result = func(array[1][2], (nested { x = 1 }).x, true);
    auto: expr = (2 * (3 + 5)).a + array[3][4];
    obj: init = vec { a = (x, y, z).c, b = array[2][1] };
    tuple: t = (5, nested::func(x, y).z, "test");
    matrix[1][0] = (10 + nested[0][0]).a;
    str: complex = (nested::call<type1, type2>(arg1, arg2)[0]).a + "suffix";
    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    value = (nested::func().a + (5 * 3)).b;
    array[1][2] = (10, 20, 30).c + matrix[2][3];
    result = { x = 5; y = -x + 2; return y * 3; };
    tuple: pair = (array[0][1], "value").a + 1;
    matrix[0][1] = vec { a = (1, 2).b, b = 3 * 2 };
    bool: valid = (x ? y : z).a && array[2][3];
    x = func(array[1][2]).b - (nested[3][4]).a;
    tuple = (vec { x = 1, y = 2 }.x, matrix[1][0]).b;
    str: output = func<type>("test").a + nested::call().b;
    array[0][2] = ((5 * 2) - tuple[1].b).c;
    matrix[2][3] = array[(5 + 3)].a * vec { x = 1 }.x;
    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    result = (nested::func<type>(arg1, arg2).a + array[0][1]).b;
    value = -(-(tuple[1].a) * (nested[2][3]).b);
    bool: check = vec { x = 10, y = 20 }.x == (5, true).a;
    str: text = "prefix" + (nested[0][1].a * 3).b;
    i32: num = func<type>(5 + (3 * 2)).a - array[1][2];
    obj: data = vec { a = (1, 2).a + matrix[0][1], b = 10 };
    result = (5, 6, vec { x = 2, y = 4 }.x).c * 2;
    tuple[0].a = nested::call<type>(arg1).a + array[1][1];
    array[1][2] = vec { a = 10, b = (2, 4).a }.b - matrix[3][0];
    nested::func()[1][2] = (5 + array[0][1].a).c;
    value = (10, vec { x = 1, y = 2 }).b + nested[1][2];
    bool: flag = (tuple[1].b > (array[1][2]).c) && nested[2][3];
    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    auto: expr = func<type>("test").a * (matrix[0][0]).b;
    array[(5 + 3)].b = nested::func<type>().a + (10, "text").c;
    tuple = (nested[0][1].a, vec { x = 1, y = 2 }.y).b;
    x = (5 + (nested::func<type>(arg1).a * array[0][2])).c;
    obj: vec = vec { x = (1, 2).b + nested::call().a, y = 20 };
    bool: comparison = ((10, 20).b == matrix[1][0]) && array[1][1];
    matrix[1][1] = vec { a = (5, "text").c, b = array[2][3] };
    tuple: data = (nested::func()[0][1].a + 2, vec { a = 1 }.a).c;
    str: message = nested::call<type>("arg").b + array[0][0];
    nested[0][1] = (10 + vec { x = 1, y = 2 }.y).a;
    i32: result = func<type>(array[1][2]).b * nested[3][4];
    matrix[0][1] = (vec { a = (3, 4).b, b = 10 }.a + array[0][1]).c;
    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    func((a, b) => x - 1);
    x = array.map((val) => val * 2);
    nested::call((arg1, arg2) => arg1 > arg2);
    auto: multiply = a => { return a * 2; };
    tuple: result = (x, y) => (x - y, x + y);
    array[0][1] = func(val => val.a + 2).b;
    auto: filter = (array) => { return array.filter((x) => x > 10); };
    func<type>((a, b) => a * b, (c) => { return c + 1; });
    obj: result = vec { a = (x, y) => x - y, b = (z) => z * 2 };
    matrix[1][0] = (a, b) => a + b - matrix[0][1];
    array.map((item) => { return item * 2; });
    auto: sum = (x, y, z) => x + y + z;
    max = (x, y) => x > y ? x : y;
    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    x = a > b ? a : b;
    auto: result = array[0] < 10 ? "low" : "high";
    bool: check = flag ? nested::call() : (5, 10).a;
    i32: value = matrix[0][1] > 0 ? matrix[0][1] : -1;
    str: message = array[0][0] == 1 ? "one" : "other";
    tuple = (5 > 3 ? "yes" : "no", array[1][2] < 0 ? -1 : 1);
    array[2][3] = flag ? (10, "value").a : vec { x = 5 }.x;
    result = nested::func() ? func<type>("arg").a : matrix[1][2];
    bool: flag = (5 + 3) > 10 ? true : false;
    auto: status = isValid ? "valid" : (nested[0][1]).b;
    matrix[0][1] = x > 0 ? array[1][1] : nested[2][3];
    obj: init = vec { a = array[0][0] ? "yes" : "no", b = flag ? 1 : 0 };
    str: response = nested::call() ? (tuple[1].b + 3).a : "default";
    tuple: result = (x == y ? 0 : 1, flag ? true : false);
    array[(5 > 3 ? 1 : 0)] = matrix[1][1] > 0 ? 10 : -10;
    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    a ? (b ? c : d) ? e : f : g;
    a ? b ? c ? d : e : f : g;
    x ? y ? z ? w : v : u : t;
    a ? b ? c : d : e;
    (a ? b : c).method() ? x : y;
    a ? b : c;
    (a ? b : c);
    (a ? b : c) ? d : e;
    (a ? b : c ? d : e);
    a ? b : c ? d : e;
    a + 1 ? b - 1 : c / 1;
    (x * 2) ? (y / 3) : (z - 4);
    a ? b + c : d * e;
    x + y ? a - b : c / d;
    (a ? b : (c ? d : e));
    ((a ? b : c) ? d : e);
    a ? (b ? c : d) : e;
    ((x + y) ? (a - b) : (c * d));
    (a + (b ? c : d)) ? e : f;
    arr[0] ? map[1] : obj.field;
    func(a, b) ? x.y : z[2];
    (a + b > c ? d - e : f / g) ? h : i;
    (a ? (b + c) : (d - e)) ? f : g; ////////////////////////////////////////////////////////////////////////////////////////fix
    (a ? b : c ? d : e) ? (f ? g : h) : i;
    (((a ? b : c) ? d : e) ? f : g);
    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    auto: result = (nested::func<type1, type2>(arg1, array[0][1] * (5 + 3)).a / vec { x = 1, y = (10, 20).b }.y) > (matrix[2][3] ? 15 : -5) ? "valid" : "invalid";
    str: response = (tuple[1].b == (nested::call(array[0][1] > 0 ? (5, 10).a : vec { x = 2 }.x) + func<type>("arg").a).c) ? "success" : "failure";
    array[1][2] = (matrix[0][1] + nested::func<type>(5, vec { x = 1 }.x).b * (10 ? (array[2][3].c / (x > y ? x : y)) : -1)).a;
    tuple: complex = ((vec { a = (nested::call(x => x + 1)).a, b = matrix[1][0] }).b + (5 > 3 ? func((x, y) => x - y, 10).b : nested[0][1].a)).c;
    result = nested::func<type>(array[1][2], vec { x = 1, y = (5, "text").a }.b).a > (tuple[2].c + (flag ? (matrix[1][1] - array[2][3]).a : "default")).b ? "pass" : "fail";
    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    x = 5 + (3 * (array[0][1] - 2));
    result = (nested::func<type>("arg", vec { x = 1, y = 2 }).a - 5).c;
    matrix[1][2] = (array[0][1] > 3 ? nested[2][3].b : (5, 10).a) * 2;
    str: message = (5 + nested::call().a) > 10 ? "high" : "low";
    tuple: data = (vec { a = 1, b = 2 }.a, array[1][2] - 5).c;
    x = (flag ? 10 : 5) + ((nested::func(array[1][2]).b * 3) - 1);
    auto: lambda = (x, y) => { return x * y + 2; };
    nested[1][0] = func(array[0][1], vec { x = 1 }.x).a - 5;
    bool: check = matrix[0][1] == vec { x = 10, y = 20 }.x;
    result = func<type>((array[1][2] * (5, 10).a).b, nested::call());
    array[2][3] = (x > y ? nested[1][1].b : (10, 20).a) + vec { a = 1 }.a;
    i32: value = func<type>(nested::call(array[0][1] * 2).a).b;
    obj: init = vec { x = (array[1][1] > 5 ? 1 : 0), y = nested[0][0].a };
    str: response = (nested::func()[0][1].b + (5 * array[2][3])).a;
    auto: expr = (tuple[1].a - (nested[2][3].b ? 10 : 5)).c;
    matrix[0][1] = vec { x = (5, 10).b, y = array[0][1] }.x + 2;
    tuple = (func(array[1][2]).b, nested[3][4].a).c + (10, "text").a;
    nested::call(array[0][1], func<type>("arg").a).b = 5 + (tuple[2].b * 2);
    array[(5, "test").a] = (nested[1][1].b - matrix[2][3]).c + 1;
    lambda = (a, b) => a > b ? a : b;
    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    result = func<type>((vec { x = 1, y = 2 }).b + array[0][1]).c;
    matrix[0][1] = (nested[2][3].b + (5, 10).a) * func(array[1][2]).a;
    tuple: data = (nested::func(array[0][1], 10).a, vec { x = 2 }.y).b;
    auto: check = (x > 5 ? (nested[0][1].b + 10) : (tuple[1].a - 3)).c;
    str: message = "value: " + nested::call<type>(array[1][1]).b;
    matrix[1][0] = (tuple[1].b > 5 ? vec { a = 1 }.a : nested[2][3].b).c;
    x = (nested::call(array[0][1] * 5).a + func<type>("arg").b) > 10 ? 1 : 0;
    auto: filter = (array) => { return array.filter((x) => x > 5); };
    tuple: result = ((nested[0][1].a * 3) - (5, "test").b).c + 10;
    func<type>((a, b) => a + b, nested[1][1].a).b = array[2][3];
    result = vec { x = nested::func(array[1][1]).b, y = (tuple[2].a - 5) };
    nested[0][1] = (5 * (matrix[2][3] - vec { x = 1 }.x)).a + 2;
    lambda = (a) => { return (nested[0][1].a + a * 5); };
    auto: sum = func((x, y) => x + y, (z) => z * 2).a;
    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    bool: valid = (matrix[0][1] == (5, "test").a) && (nested[2][3].b > 0);
    tuple: pair = vec { a = nested::call(array[1][1]).a, b = 10 }.b + 5;
    matrix[0][1] = (tuple[2].a > vec { x = 1 }.x ? nested[3][4].b : 10).c;
    str: result = (5 + (tuple[1].a - 3) * vec { a = 2 }.a).b;
    array[(nested[0][0].b > 5 ? 1 : 0)] = (matrix[1][1] * 2).a - 10;
    nested::func(array[1][2]).b = (vec { x = (10, "test").a }.a * 5).c;
    tuple = (nested::call(array[0][1]).b + (5, 10).a).c * vec { x = 1 }.a;
    i32: value = func<type>((nested[0][0].b > 3 ? 10 : 5) + 2).a;
    str: final = (nested::func<type>(array[1][2], vec { x = 1 }).a).b + "text";
    matrix[1][0] = (tuple[2].a + (nested::call(x, y).b - 10)).c * 2;
    array[2][3] = vec { x = (5 + 10) * matrix[0][1], y = (nested[1][1].a) }.x;
    bool: comparison = (x > 10 ? func(array[1][2]).a : nested[0][0].b).c == 1;
    lambda = (x, y) => { return (nested[1][1].a + x - y); };
    matrix[0][0] = func<type>((vec { x = 5 }.a + array[1][1]).c).b - 10;
    nested::call<type>(array[0][1], func<type>("arg")).b = (5 + 10) * vec { x = 1 }.x;
    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    x<a>::y<b>: z = func<c>::call<d>(args);
    a<b>::nested<c>: result = scoped<type>::compute<d>(val);
    obj<x>::key<y>: value = method<a>::invoke<b>(param1, param2);
    type1<type2>::nested<type3>: result = scoped<val1>::op<val2>(arguments);
    tuple<a>::index<b>: value = scoped<c>::func<d>(arg1, arg2);
    array<m>::nested<n>: elem = scoped<v>::op<y>(nested::call(args));
    var<x>::nested<y>: value = obj<a>::method<b>(nested::func(args));
    result<a>::nested<b>: output = scoped<type>::compute<val>(nested[0]);
    scoped<x>::nested<y>: result = method<a>::call<b>(scoped[1][2]);
    type<outer>::inner<key>: value = scoped<method>::func<args>(nested::call());
    param<x>::scoped<y>: value = type<a>::method<b>(vec { x = 1, y = 2 });
    nested<a>::nested<b>: output = scoped<c>::op<d>(tuple[1].val);
    nested<type>::inner<key>: result = func<x>::method<y>(array[2][3]);
    type1<type2>::value<type3>: result = scoped<x>::method<y>(nested::call(val));
    key<a>::func<b>: result = type<c>::call<d>(array[1][2] * 2);
    obj<x>::nested<y>: result = method<a>::invoke<b>(nested[0][1]);
    tuple<type>::index<val>: output = scoped<method>::op<args>(nested::call());
    scoped<a>::nested<b>: result = func<c>::call<d>(vec { x = 10, y = 20 });
    value<x>::type<y>: result = obj<a>::method<b>(nested[0][1].args);
    scoped<type>::key<val>: output = func<x>::call<y>(nested::op(array[2]));
    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    i32[]: array = [10, 20, 30];
    i32*: arrayPtr = &array[0];
    //i32**: doubleArrayPtr = &arrayPtr; ////////////////////////////////////////////////////////////
    bool: isDoubleArrayPtr = doubleArrayPtr is i32**;
    auto: genericArray = array;
    Nullable<i32[]>: maybeArray = genericArray as i32[];
    i32: value = 99;
    i32*: ptr = &value;
    //i32**: doublePtr = &ptr; ////////////////////////////////////////////////////////////
    //i32***: triplePtr = &doublePtr; ////////////////////////////////////////////////////////////
    i32: dereferencedValue = *(*(*triplePtr));
    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    a { b = 1, c = 2, d = 3 };
    a::pos { x = 0, y = 1 }.c + 1;
    pos { x = 5 * 2, y = 10 / 2 }.c * 3;
    pos { x = getX(), y = getY() }.normalize().x;
    a::b::c::Shape { width = 100, height = 200 }.area();
    ShapeFactory().create("Circle", radius + 10).diameter();
    TreeNode { left = null, right = TreeNode { value = 5 } }.right.value;
    Vec3 { x = 1, y = 2, z = 3 }.length() + Vec3 { x = 4, y = 5, z = 6 }.length();
    Entity { position = Vec2 { x = 10, y = 20 }, velocity = Vec2 { x = 1, y = 1 } }.move();
    Game::Character { name = "Hero", stats = StatBlock { health = 100, mana = 50 } }.stats.health;
    Renderer::Material { albedo = Color { r = 255, g = 255, b = 255 }, roughness = 0.5 }.bind();
    SceneObject { transform = Transform { pos = Vec3 { x = 0, y = 1, z = 2 }, rot = Quaternion::identity() } }.transform.pos.y;
    Graph::Node { id = 42, edges = [ Graph::Edge { to = 1, weight = 0.5 }, Graph::Edge { to = 2, weight = 1.0 } ] }.edges[1].weight;
    Matrix4x4 { values = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] }.inverse().transpose();
    Level::Tile { id = 12, meta = Meta { solid = true, visible = true } }.meta.visible;
    Widget::Button { text = "Click", onClick = handler() }.text.length();
    a{ b = c{ d = e{}.h }.i }.j;
}
// some real code to use as testing
/*{
    brace_level = (brace_level - 1); 
    if (brace_level == 0) {
        cases_lines_tokens[comma_count][semicolon_count].pop();
        done = true; 
        if (((*i) >= 1) && tokens.get(((*i) - 1)).map_or(false, (t) => { return (t.token_type == TokenType::Comma); })) {
            cases_lines_tokens.pop(); 
            patterns.pop();  
        } 
        break;  
    }
    else if ((brace_level == 1) && self.lines.get((self.__curent_parsing_line + 1)).map_or(false, (l) => { return l.get(0).map_or(false, (t) => { return (((t.token_type != TokenType::Comma) && (t.token_type != TokenType::LBrace)) && (t.token_type != TokenType::RBrace)); }); })) {
        comma_count = (comma_count + 1); 
        semicolon_count = 0; 
        has_arrow_happened = false;  
    } 
}*/


;// TODO:
// use "library"; // keyword for library imports
// #! alias // for compiler: shorthand for instantiation of class
// #! def NAME = VALUE // for compiler: define compile time constants
// #! def ADD(x, y) x + y // define function
// #! once NAME // for compiler if not defined, then define. For files
// #! ifndef NAME // spceific compile time if
// #! if ARGUMENT // if statement for compiler
// #! deprecated 
// #! allow WARNING_OR_ERROR
// #! warn WARNING_OR_ERROR
// #! error WARNING_OR_ERROR
// u0: add(u8: a, u8: b) -> "example" { }
// string: to_string() => "Obj [" + name.to_string() + "]";
// enum Files -> "description" { File1 = 0, File2 -> "1" }
// class Color -> "color class" { }
// struct Pixel { }
// typedef (u8, u8, u8) <- Color -> "description";