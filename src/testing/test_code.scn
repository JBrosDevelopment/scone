if true { one_line_of_code; }
if false { one_line_of_code; } 
if 1 + 2 == 3 { one_line_of_code; }
if (a && b) || c { one_line_of_code; }
if ((x)) { one_line_of_code; }
if func() { one_line_of_code; }
if !flag { one_line_of_code; }
if a > b && b < c || c == d { one_line_of_code; }
if x == "string" { one_line_of_code; }
if Array.isArray(arr) { one_line_of_code; }
if a ? b : c { one_line_of_code; }
if (a == b) { one_line_of_code; }
if a == b ? c > d : e < f { one_line_of_code; }
if a && (b || (c && d)) { one_line_of_code; }
if x is y { one_line_of_code; }
if key is obj { one_line_of_code; }
if a != null && a != undefined { one_line_of_code; }
if (a, b, c) { one_line_of_code; }
if ((a) => true) { one_line_of_code; }
if Boolean(false) { one_line_of_code; }
if expr.a(x => x.a) == "value" { one_line_of_code; }
if 0 == undefined { one_line_of_code; }
if a || b && c || d { one_line_of_code; }
if (((a + b)) > ((c + d))) { one_line_of_code; }
if (a == b) && ((c != d) || (e == f)) { one_line_of_code; }


// some real code to use as testing
/*{
    brace_level = (brace_level - 1); 
    if (brace_level == 0) {
        cases_lines_tokens[comma_count][semicolon_count].pop();
        done = true; 
        if (((*i) >= 1) && tokens.get(((*i) - 1)).map_or(false, (t) => { return (t.token_type == TokenType::Comma); })) {
            cases_lines_tokens.pop(); 
            patterns.pop();  
        } 
        break;  
    }
    else if ((brace_level == 1) && self.lines.get((self.__curent_parsing_line + 1)).map_or(false, (l) => { return l.get(0).map_or(false, (t) => { return (((t.token_type != TokenType::Comma) && (t.token_type != TokenType::LBrace)) && (t.token_type != TokenType::RBrace)); }); })) {
        comma_count = (comma_count + 1); 
        semicolon_count = 0; 
        has_arrow_happened = false;  
    } 
}


;// TODO:
// use "library"; // keyword for library imports
// #! alias // for compiler: shorthand for instantiation of class
// #! def NAME = VALUE // for compiler: define compile time constants
// #! def ADD(x, y) x + y // define function
// #! once NAME // for compiler if not defined, then define. For files
// #! ifndef NAME // spceific compile time if
// #! if ARGUMENT // if statement for compiler
// #! deprecated 
// #! allow WARNING_OR_ERROR
// #! warn WARNING_OR_ERROR
// #! error WARNING_OR_ERROR
// u0: add(u8: a, u8: b) -> "example" { }
// string: to_string() => "Obj [" + name.to_string() + "]";
// enum Files -> "description" { File1 = 0, File2 -> "1" }
// class Color -> "color class" { }
// struct Pixel { }
// typedef (u8, u8, u8) <- Color -> "description";