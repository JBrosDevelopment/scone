(a?b:c).d
//value = (nested::func().a + (5 * 3)).b;
//array[1][2] = (10, 20, 30).c + matrix[2][3];
//result = { x = 5; y = -x + 2; return y * 3; };
//tuple: pair = (array[0][1], "value").a + 1;
//matrix[0][1] = vec { a = (1, 2).b, b = 3 * 2 };
//bool: valid = (x ? y : z).a && array[2][3];
//x = func(array[1][2]).b - (nested[3][4]).a;
//tuple = (vec { x = 1, y = 2 }.x, matrix[1][0]).b;
//str: output = func<type>("test").a + nested::call().b;
//array[0][2] = ((5 * 2) - tuple[1].b).c;
//matrix[2][3] = array[(5 + 3)].a * vec { x = 1 }.x;

// some real code to use as testing
/*{
    brace_level = (brace_level - 1); 
    if (brace_level == 0) {
        cases_lines_tokens[comma_count][semicolon_count].pop();
        done = true; 
        if (((*i) >= 1) && tokens.get(((*i) - 1)).map_or(false, (t) => { return (t.token_type == TokenType::Comma); })) {
            cases_lines_tokens.pop(); 
            patterns.pop();  
        } 
        break;  
    }
    else if ((brace_level == 1) && self.lines.get((self.__curent_parsing_line + 1)).map_or(false, (l) => { return l.get(0).map_or(false, (t) => { return (((t.token_type != TokenType::Comma) && (t.token_type != TokenType::LBrace)) && (t.token_type != TokenType::RBrace)); }); })) {
        comma_count = (comma_count + 1); 
        semicolon_count = 0; 
        has_arrow_happened = false;  
    } 
}*/


;// TODO:
// use "library"; // keyword for library imports
// #! alias // for compiler: shorthand for instantiation of class
// #! def NAME = VALUE // for compiler: define compile time constants
// #! def ADD(x, y) x + y // define function
// #! once NAME // for compiler if not defined, then define. For files
// #! ifndef NAME // spceific compile time if
// #! if ARGUMENT // if statement for compiler
// #! deprecated 
// #! allow WARNING_OR_ERROR
// #! warn WARNING_OR_ERROR
// #! error WARNING_OR_ERROR
// u0: add(u8: a, u8: b) -> "example" { }
// string: to_string() => "Obj [" + name.to_string() + "]";
// enum Files -> "description" { File1 = 0, File2 -> "1" }
// class Color -> "color class" { }
// struct Pixel { }
// typedef (u8, u8, u8) <- Color -> "description";