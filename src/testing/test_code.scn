u8**: ptr = null;

//i32*: ptr = &x;
//i32: value = *ptr;
//auto*: genericPtr = &array[0][1];
//auto: dereferenced = *genericPtr;
//i32*: ptr = &array[0][0];
//ptr = ptr + 1;
//i32: nextValue = *ptr;
//ptr = ptr - 1;
//i32: previousValue = *ptr;
//i32*: ptr = null;
//bool: isNull = (ptr == null);
//ptr = &x;
//bool: isNotNull = (ptr != null);
//i32*: dynamicValue = alloc<i32>();
//*dynamicValue = 42;
//dealloc(dynamicValue);
//i32[]: array = [1, 2, 3, 4];
//i32*: arrayPtr = &array[0];
//i32: firstValue = *arrayPtr;
//i32: secondValue = *(arrayPtr + 1);
//Point*: pointPtr = alloc<Point>();
//pointPtr.x = 10;
//pointPtr.y = 20;
//i32: xValue = pointPtr.x;
//i32: yValue = pointPtr.y;
//dealloc(pointPtr);
//i32: value = 10;
//i32*: ptr = &value;
//i32**: doublePtr = &ptr;
//i32: dereferencedValue = **doublePtr;
//*ptr = 20;
//i32: updatedValue = **doublePtr;
//i32: a = 10;
//i32&: refA = a;
//i32*: ptrA = &refA;
//i32: valueFromPtr = *ptrA;
//refA = 20;
//i32: updatedFromRef = *ptrA;
//i32: a = 10;
//i32&: refA = a;
//i32*: ptrA = &refA;
//i32: valueFromPtr = *ptrA;
//refA = 20;
//i32: updatedFromRef = *ptrA;
//i32*: intPtr = alloc<i32>();
//*intPtr = 42;
//void*: voidPtr = intPtr;
//i32*: castedBack = (i32*)voidPtr;
//i32: valueAfterCast = *castedBack;
//dealloc(intPtr);
//i32*: ptr1 = &array[0];
//i32*: ptr2 = &array[1];
//bool: areEqual = (ptr1 == ptr2);
//bool: isLessThan = (ptr1 < ptr2);
//i32*: ptr1 = &array[0];
//i32*: ptr2 = &array[1];
//bool: areEqual = (ptr1 == ptr2);
//bool: isLessThan = (ptr1 < ptr2);

;// TODO:
// if 0 == 0 || false { }
// else if true { }
// else { }
// while true { }
// for x in array.skip(1) { }
// match name { "john" => {}, "doe" => {}, _ => {} }
// loadlib "file.dll" // load dll
// use LIB::This // include library
// use LIB::* // library with astrix includes
// use LIB::{a, b} // includes specific members
// #! alias // for compiler: shorthand for instantiation of class
// #! def NAME = VALUE // for compiler: define compile time constants
// #! def ADD(x, y) x + y // define function
// #! once NAME // for compiler if not defined, then define. For files
// #! ifndef NAME // spceific compile time if
// #! if ARGUMENT // if statement for compilers
// #! deprecated 
// #! allow WARNING_OR_ERROR
// #! warn WARNING_OR_ERROR
// #! error WARNING_OR_ERROR
// u0: add(u8: a, u8: b) -> "example" { }
// string: to_string() => "Obj [" + name.to_string() + "]";
// enum Files { File1 = 0 -> "1", File2 }
// class Color { }
// struct Pixel { }


/*

struct Array<T> {
    u64: size;
    T*: data; // Pointer to allocated memory for type T

    // Constructor
    Array<T>::new(const u64: size) {
        Array<T> {
            size: size,
            data: malloc(size * sizeof(T)) as T* // Cast malloc result to T*
        }
    }

    // Indexer for getting an element
    T: op_indexer_get(u64: index) {
        assert(index < self.size, "Index out of bounds");
        return self.data[index]; // Access the indexed element
    }

    // Indexer for setting an element
    void: op_indexer_set(u64: index, T: val) {
        assert(index < self.size, "Index out of bounds");
        self.data[index] = val; // Set the value at the indexed position
    }

    // Resize the array
    void: resize(u64: newSize) {
        self.data = realloc(self.data, newSize * sizeof(T)) as T*; // Reallocate memory
        self.size = newSize;
    }

    // Destructor to free memory
    ~Array<T>() {
        if self.data != nullptr {
            free(self.data); // Free the allocated memory
        }
    }
}

*/