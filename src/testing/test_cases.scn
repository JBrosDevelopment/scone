i32: x = (5 + 3) * -(-2);
value = (1, "test", true).b;
auto: result = array[0][1] + matrix[2][3];
point: vec = vec { x = 10, y = array[1][2] };
str: message = func<type>("arg1", (nested[1][0], "test").a);
bool: check = (x > 0 ? 1 : 2) == (tuple[0].c);
i32: value = { x: i32 = 10; y = -x * 3; return y; };
tuple: data = (3, 4, vec { a = 1, b = 2 }).c;
x = -((5 + array[0][2]) * ~(tuple[1].b));
result = func(array[1][2], (nested { x = 1 }).x, true);
auto: expr = (2 * (3 + 5)).a + array[3][4];
obj: init = vec { a = (x, y, z).c, b = array[2][1] };
tuple: t = (5, nested::func(x, y).z, "test");
matrix[1][0] = (10 + nested[0][0]).a;
str: complex = (nested::call<type1, type2>(arg1, arg2)[0]).a + "suffix";


value = (nested::func().a + (5 * 3)).b;
array[1][2] = (10, 20, 30).c + matrix[2][3];
result = { x = 5; y = -x + 2; return y * 3; };
tuple: pair = (array[0][1], "value").a + 1;
matrix[0][1] = vec { a = (1, 2).b, b = 3 * 2 };
bool: valid = (x ? y : z).a && array[2][3];
x = func(array[1][2]).b - (nested[3][4]).a;
tuple = (vec { x = 1, y = 2 }.x, matrix[1][0]).b;
str: output = func<type>("test").a + nested::call().b;
array[0][2] = ((5 * 2) - tuple[1].b).c;
matrix[2][3] = array[(5 + 3)].a * vec { x = 1 }.x;


result = (nested::func<type>(arg1, arg2).a + array[0][1]).b;
value = -(-(tuple[1].a) * (nested[2][3]).b);
bool: check = vec { x = 10, y = 20 }.x == (5, true).a;
str: text = "prefix" + (nested[0][1].a * 3).b;
i32: num = func<type>(5 + (3 * 2)).a - array[1][2];
obj: data = vec { a = (1, 2).a + matrix[0][1], b = 10 };
result = (5, 6, vec { x = 2, y = 4 }.x).c * 2;
tuple[0].a = nested::call<type>(arg1).a + array[1][1];
array[1][2] = vec { a = 10, b = (2, 4).a }.b - matrix[3][0];
nested::func()[1][2] = (5 + array[0][1].a).c;
value = (10, vec { x = 1, y = 2 }).b + nested[1][2];
bool: flag = (tuple[1].b > (array[1][2]).c) && nested[2][3];


auto: expr = func<type>("test").a * (matrix[0][0]).b;
array[(5 + 3)].b = nested::func<type>().a + (10, "text").c;
tuple = (nested[0][1].a, vec { x = 1, y = 2 }.y).b;
x = (5 + (nested::func<type>(arg1).a * array[0][2])).c;
obj: vec = vec { x = (1, 2).b + nested::call().a, y = 20 };
bool: comparison = ((10, 20).b == matrix[1][0]) && array[1][1];
matrix[1][1] = vec { a = (5, "text").c, b = array[2][3] };
tuple: data = (nested::func()[0][1].a + 2, vec { a = 1 }.a).c;
str: message = nested::call<type>("arg").b + array[0][0];
nested[0][1] = (10 + vec { x = 1, y = 2 }.y).a;
i32: result = func<type>(array[1][2]).b * nested[3][4];
matrix[0][1] = (vec { a = (3, 4).b, b = 10 }.a + array[0][1]).c;


func((a, b) => x - 1);
x = array.map((val) => val * 2);
nested::call((arg1, arg2) => arg1 > arg2);
auto: multiply = a => { return a * 2; };
tuple: result = (x, y) => (x - y, x + y);
array[0][1] = func(val => val.a + 2).b;
auto: filter = (array) => { return array.filter((x) => x > 10); };
func<type>((a, b) => a * b, (c) => { return c + 1; });
obj: result = vec { a = (x, y) => x - y, b = (z) => z * 2 };
matrix[1][0] = (a, b) => a + b - matrix[0][1];
array.map((item) => { return item * 2; });
auto: sum = (x, y, z) => x + y + z;
max = (x, y) => x > y ? x : y;


x = a > b ? a : b;
auto: result = array[0] < 10 ? "low" : "high";
bool: check = flag ? nested::call() : (5, 10).a;
i32: value = matrix[0][1] > 0 ? matrix[0][1] : -1;
str: message = array[0][0] == 1 ? "one" : "other";
tuple = (5 > 3 ? "yes" : "no", array[1][2] < 0 ? -1 : 1);
array[2][3] = flag ? (10, "value").a : vec { x = 5 }.x;
result = nested::func() ? func<type>("arg").a : matrix[1][2];
bool: flag = (5 + 3) > 10 ? true : false;
auto: status = isValid ? "valid" : (nested[0][1]).b;
matrix[0][1] = x > 0 ? array[1][1] : nested[2][3];
obj: init = vec { a = array[0][0] ? "yes" : "no", b = flag ? 1 : 0 };
str: response = nested::call() ? (tuple[1].b + 3).a : "default";
tuple: result = (x == y ? 0 : 1, flag ? true : false);
array[(5 > 3 ? 1 : 0)] = matrix[1][1] > 0 ? 10 : -10;

a ? (b ? c : d) ? e : f : g;
a ? b ? c ? d : e : f : g;
x ? y ? z ? w : v : u : t;
a ? b ? c : d : e;
(a ? b : c).method() ? x : y;
a ? b : c;
(a ? b : c);
(a ? b : c) ? d : e;
(a ? b : c ? d : e);
a ? b : c ? d : e;
a + 1 ? b - 1 : c / 1;
(x * 2) ? (y / 3) : (z - 4);
a ? b + c : d * e;
x + y ? a - b : c / d;
(a ? b : (c ? d : e));
((a ? b : c) ? d : e);
a ? (b ? c : d) : e;
((x + y) ? (a - b) : (c * d));
(a + (b ? c : d)) ? e : f;
arr[0] ? map[1] : obj.field;
func(a, b) ? x.y : z[2];
(a + b > c ? d - e : f / g) ? h : i;
(a ? (b + c) : (d - e)) ? f : g;
(a ? b : c ? d : e) ? (f ? g : h) : i;
(((a ? b : c) ? d : e) ? f : g);


auto: result = (nested::func<type1, type2>(arg1, array[0][1] * (5 + 3)).a / vec { x = 1, y = (10, 20).b }.y) > (matrix[2][3] ? 15 : -5) ? "valid" : "invalid";
str: response = (tuple[1].b == (nested::call(array[0][1] > 0 ? (5, 10).a : vec { x = 2 }.x) + func<type>("arg").a).c) ? "success" : "failure";
array[1][2] = (matrix[0][1] + nested::func<type>(5, vec { x = 1 }.x).b * (10 ? (array[2][3].c / (x > y ? x : y)) : -1)).a;
tuple: complex = ((vec { a = (nested::call(x => x + 1)).a, b = matrix[1][0] }).b + (5 > 3 ? func((x, y) => x - y, 10).b : nested[0][1].a)).c;
result = nested::func<type>(array[1][2], vec { x = 1, y = (5, "text").a }.b).a > (tuple[2].c + (flag ? (matrix[1][1] - array[2][3]).a : "default")).b ? "pass" : "fail";

x = 5 + (3 * (array[0][1] - 2));
result = (nested::func<type>("arg", vec { x = 1, y = 2 }).a - 5).c;
matrix[1][2] = (array[0][1] > 3 ? nested[2][3].b : (5, 10).a) * 2;
str: message = (5 + nested::call().a) > 10 ? "high" : "low";
tuple: data = (vec { a = 1, b = 2 }.a, array[1][2] - 5).c;
x = (flag ? 10 : 5) + ((nested::func(array[1][2]).b * 3) - 1);
auto: lambda = (x, y) => { return x * y + 2; };
nested[1][0] = func(array[0][1], vec { x = 1 }.x).a - 5;
bool: check = matrix[0][1] == vec { x = 10, y = 20 }.x;
result = func<type>((array[1][2] * (5, 10).a).b, nested::call());
array[2][3] = (x > y ? nested[1][1].b : (10, 20).a) + vec { a = 1 }.a;
i32: value = func<type>(nested::call(array[0][1] * 2).a).b;
obj: init = vec { x = (array[1][1] > 5 ? 1 : 0), y = nested[0][0].a };
str: response = (nested::func()[0][1].b + (5 * array[2][3])).a;
auto: expr = (tuple[1].a - (nested[2][3].b ? 10 : 5)).c;
matrix[0][1] = vec { x = (5, 10).b, y = array[0][1] }.x + 2;
tuple = (func(array[1][2]).b, nested[3][4].a).c + (10, "text").a;
nested::call(array[0][1], func<type>("arg").a).b = 5 + (tuple[2].b * 2);
array[(5, "test").a] = (nested[1][1].b - matrix[2][3]).c + 1;
lambda = (a, b) => a > b ? a : b;

result = func<type>((vec { x = 1, y = 2 }).b + array[0][1]).c;
matrix[0][1] = (nested[2][3].b + (5, 10).a) * func(array[1][2]).a;
tuple: data = (nested::func(array[0][1], 10).a, vec { x = 2 }.y).b;
auto: check = (x > 5 ? (nested[0][1].b + 10) : (tuple[1].a - 3)).c;
str: message = "value: " + nested::call<type>(array[1][1]).b;
matrix[1][0] = (tuple[1].b > 5 ? vec { a = 1 }.a : nested[2][3].b).c;
x = (nested::call(array[0][1] * 5).a + func<type>("arg").b) > 10 ? 1 : 0;
auto: filter = (array) => { return array.filter((x) => x > 5); };
tuple: result = ((nested[0][1].a * 3) - (5, "test").b).c + 10;
func<type>((a, b) => a + b, nested[1][1].a).b = array[2][3];
result = vec { x = nested::func(array[1][1]).b, y = (tuple[2].a - 5) };
nested[0][1] = (5 * (matrix[2][3] - vec { x = 1 }.x)).a + 2;
lambda = (a) => { return (nested[0][1].a + a * 5); };
auto: sum = func((x, y) => x + y, (z) => z * 2).a;

bool: valid = (matrix[0][1] == (5, "test").a) && (nested[2][3].b > 0);
tuple: pair = vec { a = nested::call(array[1][1]).a, b = 10 }.b + 5;
matrix[0][1] = (tuple[2].a > vec { x = 1 }.x ? nested[3][4].b : 10).c; 
str: result = (5 + (tuple[1].a - 3) * vec { a = 2 }.a).b;
array[(nested[0][0].b > 5 ? 1 : 0)] = (matrix[1][1] * 2).a - 10;
nested::func(array[1][2]).b = (vec { x = (10, "test").a }.a * 5).c;
tuple = (nested::call(array[0][1]).b + (5, 10).a).c * vec { x = 1 }.a;
i32: value = func<type>((nested[0][0].b > 3 ? 10 : 5) + 2).a;
str: final = (nested::func<type>(array[1][2], vec { x = 1 }).a).b + "text";
matrix[1][0] = (tuple[2].a + (nested::call(x, y).b - 10)).c * 2;
array[2][3] = vec { x = (5 + 10) * matrix[0][1], y = (nested[1][1].a) }.x;
bool: comparison = (x > 10 ? func(array[1][2]).a : nested[0][0].b).c == 1;
lambda = (x, y) => { return (nested[1][1].a + x - y); };
matrix[0][0] = func<type>((vec { x = 5 }.a + array[1][1]).c).b - 10;
nested::call<type>(array[0][1], func<type>("arg")).b = (5 + 10) * vec { x = 1 }.x;

x<a>::y<b>: z = func<c>::call<d>(args);
a<b>::nested<c>: result = scoped<type>::compute<d>(val);
obj<x>::key<y>: value = method<a>::invoke<b>(param1, param2);
type1<type2>::nested<type3>: result = scoped<val1>::op<val2>(arguments);
tuple<a>::index<b>: value = scoped<c>::func<d>(arg1, arg2);
array<m>::nested<n>: elem = scoped<v>::op<y>(nested::call(args));
var<x>::nested<y>: value = obj<a>::method<b>(nested::func(args));
result<a>::nested<b>: output = scoped<type>::compute<val>(nested[0]);
scoped<x>::nested<y>: result = method<a>::call<b>(scoped[1][2]);
type<outer>::inner<key>: value = scoped<method>::func<args>(nested::call());
param<x>::scoped<y>: value = type<a>::method<b>(vec { x = 1, y = 2 });
nested<a>::nested<b>: output = scoped<c>::op<d>(tuple[1].val);
nested<type>::inner<key>: result = func<x>::method<y>(array[2][3]);
type1<type2>::value<type3>: result = scoped<x>::method<y>(nested::call(val));
key<a>::func<b>: result = type<c>::call<d>(array[1][2] * 2);
obj<x>::nested<y>: result = method<a>::invoke<b>(nested[0][1]);
tuple<type>::index<val>: output = scoped<method>::op<args>(nested::call());
scoped<a>::nested<b>: result = func<c>::call<d>(vec { x = 10, y = 20 });
value<x>::type<y>: result = obj<a>::method<b>(nested[0][1].args);
scoped<type>::key<val>: output = func<x>::call<y>(nested::op(array[2]));

i32[]: array = [10, 20, 30];
i32*: arrayPtr = &array[0];
i32**: doubleArrayPtr = &arrayPtr;
bool: isDoubleArrayPtr = doubleArrayPtr is i32**;
auto: genericArray = array;
Nullable<i32>: maybeArray = genericArray as i32[];
i32: value = 99;
i32*: ptr = &value;
i32**: doublePtr = &ptr;
i32***: triplePtr = &doublePtr;
i32: dereferencedValue = *(*(*triplePtr));


a { b = 1, c = 2, d = 3 };
a::pos { x = 0, y = 1 }.c + 1;
pos { x = 5 * 2, y = 10 / 2 }.c * 3;
pos { x = getX(), y = getY() }.normalize().x;
a::b::c::Shape { width = 100, height = 200 }.area();
ShapeFactory().create("Circle", radius + 10).diameter();
TreeNode { left = null, right = TreeNode { value = 5 } }.right.value;
Vec3 { x = 1, y = 2, z = 3 }.length() + Vec3 { x = 4, y = 5, z = 6 }.length();
Entity { position = Vec2 { x = 10, y = 20 }, velocity = Vec2 { x = 1, y = 1 } }.move();
Game::Character { name = "Hero", stats = StatBlock { health = 100, mana = 50 } }.stats.health;
Renderer::Material { albedo = Color { r = 255, g = 255, b = 255 }, roughness = 0.5 }.bind();
SceneObject { transform = Transform { pos = Vec3 { x = 0, y = 1, z = 2 }, rot = Quaternion::identity() } }.transform.pos.y;
Graph::Node { id = 42, edges = [ Graph::Edge { to = 1, weight = 0.5 }, Graph::Edge { to = 2, weight = 1.0 } ] }.edges[1].weight;
Matrix4x4 { values = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] }.inverse().transpose();
Level::Tile { id = 12, meta = Meta { solid = true, visible = true } }.meta.visible;
Widget::Button { text = "Click", onClick = handler() }.text.length();
a{ b = c{ d = e{}.h }.i }.j;


// bracketed
{
    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    i32: x = (5 + 3) * -(-2);
    value = (1, "test", true).b;
    auto: result = array[0][1] + matrix[2][3];
    point: vec = vec { x = 10, y = array[1][2] };
    str: message = func<type>("arg1", (nested[1][0], "test").a);
    bool: check = (x > 0 ? 1 : 2) == (tuple[0].c);
    i32: value = { x: i32 = 10; y = -x * 3; return y; };
    tuple: data = (3, 4, vec { a = 1, b = 2 }).c;
    x = -((5 + array[0][2]) * ~(tuple[1].b));
    result = func(array[1][2], (nested { x = 1 }).x, true);
    auto: expr = (2 * (3 + 5)).a + array[3][4];
    obj: init = vec { a = (x, y, z).c, b = array[2][1] };
    tuple: t = (5, nested::func(x, y).z, "test");
    matrix[1][0] = (10 + nested[0][0]).a;
    str: complex = (nested::call<type1, type2>(arg1, arg2)[0]).a + "suffix";
    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    value = (nested::func().a + (5 * 3)).b;
    array[1][2] = (10, 20, 30).c + matrix[2][3];
    result = { x = 5; y = -x + 2; return y * 3; };
    tuple: pair = (array[0][1], "value").a + 1;
    matrix[0][1] = vec { a = (1, 2).b, b = 3 * 2 };
    bool: valid = (x ? y : z).a && array[2][3];
    x = func(array[1][2]).b - (nested[3][4]).a;
    tuple = (vec { x = 1, y = 2 }.x, matrix[1][0]).b;
    str: output = func<type>("test").a + nested::call().b;
    array[0][2] = ((5 * 2) - tuple[1].b).c;
    matrix[2][3] = array[(5 + 3)].a * vec { x = 1 }.x;
    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    result = (nested::func<type>(arg1, arg2).a + array[0][1]).b;
    value = -(-(tuple[1].a) * (nested[2][3]).b);
    bool: check = vec { x = 10, y = 20 }.x == (5, true).a;
    str: text = "prefix" + (nested[0][1].a * 3).b;
    i32: num = func<type>(5 + (3 * 2)).a - array[1][2];
    obj: data = vec { a = (1, 2).a + matrix[0][1], b = 10 };
    result = (5, 6, vec { x = 2, y = 4 }.x).c * 2;
    tuple[0].a = nested::call<type>(arg1).a + array[1][1];
    array[1][2] = vec { a = 10, b = (2, 4).a }.b - matrix[3][0];
    nested::func()[1][2] = (5 + array[0][1].a).c;
    value = (10, vec { x = 1, y = 2 }).b + nested[1][2];
    bool: flag = (tuple[1].b > (array[1][2]).c) && nested[2][3];
    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    auto: expr = func<type>("test").a * (matrix[0][0]).b;
    array[(5 + 3)].b = nested::func<type>().a + (10, "text").c;
    tuple = (nested[0][1].a, vec { x = 1, y = 2 }.y).b;
    x = (5 + (nested::func<type>(arg1).a * array[0][2])).c;
    obj: vec = vec { x = (1, 2).b + nested::call().a, y = 20 };
    bool: comparison = ((10, 20).b == matrix[1][0]) && array[1][1];
    matrix[1][1] = vec { a = (5, "text").c, b = array[2][3] };
    tuple: data = (nested::func()[0][1].a + 2, vec { a = 1 }.a).c;
    str: message = nested::call<type>("arg").b + array[0][0];
    nested[0][1] = (10 + vec { x = 1, y = 2 }.y).a;
    i32: result = func<type>(array[1][2]).b * nested[3][4];
    matrix[0][1] = (vec { a = (3, 4).b, b = 10 }.a + array[0][1]).c;
    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    func((a, b) => x - 1);
    x = array.map((val) => val * 2);
    nested::call((arg1, arg2) => arg1 > arg2);
    auto: multiply = a => { return a * 2; };
    tuple: result = (x, y) => (x - y, x + y);
    array[0][1] = func(val => val.a + 2).b;
    auto: filter = (array) => { return array.filter((x) => x > 10); };
    func<type>((a, b) => a * b, (c) => { return c + 1; });
    obj: result = vec { a = (x, y) => x - y, b = (z) => z * 2 };
    matrix[1][0] = (a, b) => a + b - matrix[0][1];
    array.map((item) => { return item * 2; });
    auto: sum = (x, y, z) => x + y + z;
    max = (x, y) => x > y ? x : y;
    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    x = a > b ? a : b;
    auto: result = array[0] < 10 ? "low" : "high";
    bool: check = flag ? nested::call() : (5, 10).a;
    i32: value = matrix[0][1] > 0 ? matrix[0][1] : -1;
    str: message = array[0][0] == 1 ? "one" : "other";
    tuple = (5 > 3 ? "yes" : "no", array[1][2] < 0 ? -1 : 1);
    array[2][3] = flag ? (10, "value").a : vec { x = 5 }.x;
    result = nested::func() ? func<type>("arg").a : matrix[1][2];
    bool: flag = (5 + 3) > 10 ? true : false;
    auto: status = isValid ? "valid" : (nested[0][1]).b;
    matrix[0][1] = x > 0 ? array[1][1] : nested[2][3];
    obj: init = vec { a = array[0][0] ? "yes" : "no", b = flag ? 1 : 0 };
    str: response = nested::call() ? (tuple[1].b + 3).a : "default";
    tuple: result = (x == y ? 0 : 1, flag ? true : false);
    array[(5 > 3 ? 1 : 0)] = matrix[1][1] > 0 ? 10 : -10;
    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    a ? (b ? c : d) ? e : f : g;
    a ? b ? c ? d : e : f : g;
    x ? y ? z ? w : v : u : t;
    a ? b ? c : d : e;
    (a ? b : c).method() ? x : y;
    a ? b : c;
    (a ? b : c);
    (a ? b : c) ? d : e;
    (a ? b : c ? d : e);
    a ? b : c ? d : e;
    a + 1 ? b - 1 : c / 1;
    (x * 2) ? (y / 3) : (z - 4);
    a ? b + c : d * e;
    x + y ? a - b : c / d;
    (a ? b : (c ? d : e));
    ((a ? b : c) ? d : e);
    a ? (b ? c : d) : e;
    ((x + y) ? (a - b) : (c * d));
    (a + (b ? c : d)) ? e : f;
    arr[0] ? map[1] : obj.field;
    func(a, b) ? x.y : z[2];
    (a + b > c ? d - e : f / g) ? h : i;
    (a ? (b + c) : (d - e)) ? f : g; 
    (a ? b : c ? d : e) ? (f ? g : h) : i;
    (((a ? b : c) ? d : e) ? f : g);
    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    auto: result = (nested::func<type1, type2>(arg1, array[0][1] * (5 + 3)).a / vec { x = 1, y = (10, 20).b }.y) > (matrix[2][3] ? 15 : -5) ? "valid" : "invalid";
    str: response = (tuple[1].b == (nested::call(array[0][1] > 0 ? (5, 10).a : vec { x = 2 }.x) + func<type>("arg").a).c) ? "success" : "failure";
    array[1][2] = (matrix[0][1] + nested::func<type>(5, vec { x = 1 }.x).b * (10 ? (array[2][3].c / (x > y ? x : y)) : -1)).a;
    tuple: complex = ((vec { a = (nested::call(x => x + 1)).a, b = matrix[1][0] }).b + (5 > 3 ? func((x, y) => x - y, 10).b : nested[0][1].a)).c;
    result = nested::func<type>(array[1][2], vec { x = 1, y = (5, "text").a }.b).a > (tuple[2].c + (flag ? (matrix[1][1] - array[2][3]).a : "default")).b ? "pass" : "fail";
    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    x = 5 + (3 * (array[0][1] - 2));
    result = (nested::func<type>("arg", vec { x = 1, y = 2 }).a - 5).c;
    matrix[1][2] = (array[0][1] > 3 ? nested[2][3].b : (5, 10).a) * 2;
    str: message = (5 + nested::call().a) > 10 ? "high" : "low";
    tuple: data = (vec { a = 1, b = 2 }.a, array[1][2] - 5).c;
    x = (flag ? 10 : 5) + ((nested::func(array[1][2]).b * 3) - 1);
    auto: lambda = (x, y) => { return x * y + 2; };
    nested[1][0] = func(array[0][1], vec { x = 1 }.x).a - 5;
    bool: check = matrix[0][1] == vec { x = 10, y = 20 }.x;
    result = func<type>((array[1][2] * (5, 10).a).b, nested::call());
    array[2][3] = (x > y ? nested[1][1].b : (10, 20).a) + vec { a = 1 }.a;
    i32: value = func<type>(nested::call(array[0][1] * 2).a).b;
    obj: init = vec { x = (array[1][1] > 5 ? 1 : 0), y = nested[0][0].a };
    str: response = (nested::func()[0][1].b + (5 * array[2][3])).a;
    auto: expr = (tuple[1].a - (nested[2][3].b ? 10 : 5)).c;
    matrix[0][1] = vec { x = (5, 10).b, y = array[0][1] }.x + 2;
    tuple = (func(array[1][2]).b, nested[3][4].a).c + (10, "text").a;
    nested::call(array[0][1], func<type>("arg").a).b = 5 + (tuple[2].b * 2);
    array[(5, "test").a] = (nested[1][1].b - matrix[2][3]).c + 1;
    lambda = (a, b) => a > b ? a : b;
    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    result = func<type>((vec { x = 1, y = 2 }).b + array[0][1]).c;
    matrix[0][1] = (nested[2][3].b + (5, 10).a) * func(array[1][2]).a;
    tuple: data = (nested::func(array[0][1], 10).a, vec { x = 2 }.y).b;
    auto: check = (x > 5 ? (nested[0][1].b + 10) : (tuple[1].a - 3)).c;
    str: message = "value: " + nested::call<type>(array[1][1]).b;
    matrix[1][0] = (tuple[1].b > 5 ? vec { a = 1 }.a : nested[2][3].b).c;
    x = (nested::call(array[0][1] * 5).a + func<type>("arg").b) > 10 ? 1 : 0;
    auto: filter = (array) => { return array.filter((x) => x > 5); };
    tuple: result = ((nested[0][1].a * 3) - (5, "test").b).c + 10;
    func<type>((a, b) => a + b, nested[1][1].a).b = array[2][3];
    result = vec { x = nested::func(array[1][1]).b, y = (tuple[2].a - 5) };
    nested[0][1] = (5 * (matrix[2][3] - vec { x = 1 }.x)).a + 2;
    lambda = (a) => { return (nested[0][1].a + a * 5); };
    auto: sum = func((x, y) => x + y, (z) => z * 2).a;
    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    bool: valid = (matrix[0][1] == (5, "test").a) && (nested[2][3].b > 0);
    tuple: pair = vec { a = nested::call(array[1][1]).a, b = 10 }.b + 5;
    matrix[0][1] = (tuple[2].a > vec { x = 1 }.x ? nested[3][4].b : 10).c;
    str: result = (5 + (tuple[1].a - 3) * vec { a = 2 }.a).b;
    array[(nested[0][0].b > 5 ? 1 : 0)] = (matrix[1][1] * 2).a - 10;
    nested::func(array[1][2]).b = (vec { x = (10, "test").a }.a * 5).c;
    tuple = (nested::call(array[0][1]).b + (5, 10).a).c * vec { x = 1 }.a;
    i32: value = func<type>((nested[0][0].b > 3 ? 10 : 5) + 2).a;
    str: final = (nested::func<type>(array[1][2], vec { x = 1 }).a).b + "text";
    matrix[1][0] = (tuple[2].a + (nested::call(x, y).b - 10)).c * 2;
    array[2][3] = vec { x = (5 + 10) * matrix[0][1], y = (nested[1][1].a) }.x;
    bool: comparison = (x > 10 ? func(array[1][2]).a : nested[0][0].b).c == 1;
    lambda = (x, y) => { return (nested[1][1].a + x - y); };
    matrix[0][0] = func<type>((vec { x = 5 }.a + array[1][1]).c).b - 10;
    nested::call<type>(array[0][1], func<type>("arg")).b = (5 + 10) * vec { x = 1 }.x;
    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    x<a>::y<b>: z = func<c>::call<d>(args);
    a<b>::nested<c>: result = scoped<type>::compute<d>(val);
    obj<x>::key<y>: value = method<a>::invoke<b>(param1, param2);
    type1<type2>::nested<type3>: result = scoped<val1>::op<val2>(arguments);
    tuple<a>::index<b>: value = scoped<c>::func<d>(arg1, arg2);
    array<m>::nested<n>: elem = scoped<v>::op<y>(nested::call(args));
    var<x>::nested<y>: value = obj<a>::method<b>(nested::func(args));
    result<a>::nested<b>: output = scoped<type>::compute<val>(nested[0]);
    scoped<x>::nested<y>: result = method<a>::call<b>(scoped[1][2]);
    type<outer>::inner<key>: value = scoped<method>::func<args>(nested::call());
    param<x>::scoped<y>: value = type<a>::method<b>(vec { x = 1, y = 2 });
    nested<a>::nested<b>: output = scoped<c>::op<d>(tuple[1].val);
    nested<type>::inner<key>: result = func<x>::method<y>(array[2][3]);
    type1<type2>::value<type3>: result = scoped<x>::method<y>(nested::call(val));
    key<a>::func<b>: result = type<c>::call<d>(array[1][2] * 2);
    obj<x>::nested<y>: result = method<a>::invoke<b>(nested[0][1]);
    tuple<type>::index<val>: output = scoped<method>::op<args>(nested::call());
    scoped<a>::nested<b>: result = func<c>::call<d>(vec { x = 10, y = 20 });
    value<x>::type<y>: result = obj<a>::method<b>(nested[0][1].args);
    scoped<type>::key<val>: output = func<x>::call<y>(nested::op(array[2]));
    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    i32: array = [10, 20, 30];
    i32*: arrayPtr = &array[0];
    //i32**: doubleArrayPtr = &arrayPtr; ////////////////////////////////////////////////////////////
    bool: isDoubleArrayPtr = doubleArrayPtr is i32**;
    auto: genericArray = array;
    i32: value = 99;
    i32*: ptr = &value;
    //i32**: doublePtr = &ptr; ////////////////////////////////////////////////////////////
    //i32***: triplePtr = &doublePtr; ////////////////////////////////////////////////////////////
    i32: dereferencedValue = *(*(*triplePtr));
    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    a { b = 1, c = 2, d = 3 };
    a::pos { x = 0, y = 1 }.c + 1;
    pos { x = 5 * 2, y = 10 / 2 }.c * 3;
    pos { x = getX(), y = getY() }.normalize().x;
    a::b::c::Shape { width = 100, height = 200 }.area();
    ShapeFactory().create("Circle", radius + 10).diameter();
    TreeNode { left = null, right = TreeNode { value = 5 } }.right.value;
    Vec3 { x = 1, y = 2, z = 3 }.length() + Vec3 { x = 4, y = 5, z = 6 }.length();
    Entity { position = Vec2 { x = 10, y = 20 }, velocity = Vec2 { x = 1, y = 1 } }.move();
    Game::Character { name = "Hero", stats = StatBlock { health = 100, mana = 50 } }.stats.health;
    Renderer::Material { albedo = Color { r = 255, g = 255, b = 255 }, roughness = 0.5 }.bind();
    SceneObject { transform = Transform { pos = Vec3 { x = 0, y = 1, z = 2 }, rot = Quaternion::identity() } }.transform.pos.y;
    Graph::Node { id = 42, edges = [ Graph::Edge { to = 1, weight = 0.5 }, Graph::Edge { to = 2, weight = 1.0 } ] }.edges[1].weight;
    Matrix4x4 { values = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] }.inverse().transpose();
    Level::Tile { id = 12, meta = Meta { solid = true, visible = true } }.meta.visible;
    Widget::Button { text = "Click", onClick = handler() }.text.length();
    a{ b = c{ d = e{}.h }.i }.j;
}


if true {
    a;
    if false {
        if a {
            if b {
                if c {
                    s;
                    if d {
                        if e {
                            f;
                        } else {
                            g;
                        }
                    } else {
                        h;
                    }
                } else {

                }
            }
        }
    } else if true {
        // do something
    } else {
        // do something else
    }
} else if false {
    // do something else if
} else {
    // do something else
}

{
    brace_level = (brace_level - 1); 
    if (brace_level == 0) {
        cases_lines_tokens[comma_count][semicolon_count].pop();
        done = true; 
        if (((*i) >= 1) && tokens.get(((*i) - 1)).map_or(false, (t) => { return (t.token_type == TokenType::Comma); })) {
            cases_lines_tokens.pop(); 
            patterns.pop();  
        } 
        break;  
    }
    else if ((brace_level == 1) && self.lines.get((self.__curent_parsing_line + 1)).map_or(false, (l) => { return l.get(0).map_or(false, (t) => { return (((t.token_type != TokenType::Comma) && (t.token_type != TokenType::LBrace)) && (t.token_type != TokenType::RBrace)); }); })) {
        comma_count = (comma_count + 1); 
        semicolon_count = 0; 
        has_arrow_happened = false;  
    } 
}

match a.b(c => d.e, f + g).h().i {
    1 | 2 => a.b(c => d.e, f + g).h,
    _ => {
        hello.world = 1 + 2;
        match a.b(c => d.e, f + g).h {
            1 | 2 => a.b(c => d.e, f + g).h,
            _ => {
                hello.world = 1 + 2;
                match a.b(c => d.e, f + g).h {
                    1 | 2 => a.b(c => d.e, f + g).h,
                    _ => {
                        hello.world = 1 + 2;
                        match a.b(c => d.e, f + g).h {
                            1 | 2 => a.b(c => d.e, f + g).h,
                            _ => {}
                        }
                    }
                }
            }
        }
    }
}

if a {
    Thing: things = [];
    for c in things.colors.iter().filter(x => x.is_good()).collect() {
        Thing: t = Thing {};
        t.color.red = c.red;
        t.color.green = c.green;
        t.color.blue = c.blue;
        t.color.alpha = c.alpha;
        t.name = "COLOR";
        for x in things {
            if x.color.red == c.red && x.color.green == c.green && x.color.blue == c.blue && x.color.alpha == c.alpha {
                t.name = "COLOR | " + x.name.to_string();
                break;
            }
        }
        things.push(t);
    }
} else if b {
    Thing: things = [];
    for index, c in things.colors.iter().filter(x => x.is_good()).collect() {
        Thing: t = Thing {};
        t.color.red = c.red;
        t.color.green = c.green;
        t.color.blue = c.blue;
        t.color.alpha = c.alpha;
        t.name = "COLOR " + index.to_string();
        for x in things {
            if x.color.red == c.red && x.color.green == c.green && x.color.blue == c.blue && x.color.alpha == c.alpha {
                t.name = "COLOR | " + x.name.to_string();
                break;
            }
        }
        things.push(t);
    }
} else if c {
    Thing: things = [];
    Color: colors = things.colors.iter().filter(x => x.is_good()).collect();
    for usize: i = 0, i < colors.len(), i += 1 {
        Thing: t = Thing {};
        t.color.red = colors[i].red;
        t.color.green = colors[i].green;
        t.color.blue = colors[i].blue;
        t.color.alpha = colors[i].alpha;
        t.name = "COLOR";
        for x in things {
            if x.color.red == c.red && x.color.green == c.green && x.color.blue == c.blue && x.color.alpha == c.alpha {
                t.name = "COLOR | " + x.name.to_string();
                break;
            }
        }
        things.push(t);
    }
} else {
    Thing: things = [];
    Color: colors = things.colors.iter().filter(x => x.is_good()).collect();
    for index, usize: i = 1, i < colors.len(), i += 1 {
        Thing: t = Thing {};
        t.color.red = colors[i].red;
        t.color.green = colors[i].green;
        t.color.blue = colors[i].blue;
        t.color.alpha = colors[i].alpha;
        t.name = "COLOR " + index.to_string();
        for x in things {
            if x.color.red == c.red && x.color.green == c.green && x.color.blue == c.blue && x.color.alpha == c.alpha {
                t.name = "COLOR | " + x.name.to_string();
                break;
            }
        }
        things.push(t);
    }
}

use "iostream";

i32*: number = 0;
std::cout("Enter a number: ");
std::cin(&number);
std::cout("You entered: " + number + std::endl);

false.a;
"hi".b;
'!'.c;
1_f32.d;
1.e;
1.0.f;

use "error_handling";
use "lexer";
use "ast";
use "parser";


void: main() {
    string: path = "src/testing/test_code.scn".to_string();
    string: code = std::fs::read_to_string(&path).unwrap();
    
    // lexer
    Token: tokens = lexer::lex(&code, &path);
    
    string: json = serde_json::to_string_pretty(&tokens).unwrap();
    std::fs::write("src/testing/lexer.out.json", json).unwrap();

    // parser    
    ASTNode: ast = parser::parse(tokens, &path, &code);

    string: fmt_json = serde_json::to_string_pretty(&ast).unwrap();
    std::fs::write("src/testing/parser.out.json", fmt_json).unwrap();
}


if char::is_alphabetic(c.clone()) || c == '_' {
    string: name = String::new();

    while i < chars.len() {
        if char::is_alphanumeric(chars[i]) || char::is_numeric(chars[i]) || chars[i] == '_' {
            name.push(chars[i]);
            i += 1;
        } else {
            break;
        }
    }

    current_location.advance(name.len() as i32);

    Token: new_token = match name.as_str() {
        "true" | "false" => Token::new(TokenType::BoolConstant, name.clone(), current_location.clone()),
        "return" => Token::new(TokenType::Return, name.clone(), current_location.clone()),
        "if" => Token::new(TokenType::If, name.clone(), current_location.clone()),
        "else" => Token::new(TokenType::Else, name.clone(), current_location.clone()),
        "for" => Token::new(TokenType::For, name.clone(), current_location.clone()),
        "while" => Token::new(TokenType::While, name.clone(), current_location.clone()),
        "break" => Token::new(TokenType::Break, name.clone(), current_location.clone()),
        "continue" => Token::new(TokenType::Continue, name.clone(), current_location.clone()),
        "class" => Token::new(TokenType::Class, name.clone(), current_location.clone()),
        "struct" => Token::new(TokenType::Struct, name.clone(), current_location.clone()),
        "enum" => Token::new(TokenType::Enum, name.clone(), current_location.clone()),
        "use" => Token::new(TokenType::Use, name.clone(), current_location.clone()),
        "trait" => Token::new(TokenType::Trait, name.clone(), current_location.clone()),
        "in" => Token::new(TokenType::In, name.clone(), current_location.clone()),
        "as" => Token::new(TokenType::As, name.clone(), current_location.clone()),
        "is" => Token::new(TokenType::Is, name.clone(), current_location.clone()),
        "const" => Token::new(TokenType::Const, name.clone(), current_location.clone()),
        "static" => Token::new(TokenType::Static, name.clone(), current_location.clone()),
        "pub" => Token::new(TokenType::Pub, name.clone(), current_location.clone()),
        "priv" => Token::new(TokenType::Priv, name.clone(), current_location.clone()),
        "virtual" => Token::new(TokenType::Virtual, name.clone(), current_location.clone()),
        "override" => Token::new(TokenType::Override, name.clone(), current_location.clone()),
        "match" => Token::new(TokenType::Match, name.clone(), current_location.clone()),
        "extern" => Token::new(TokenType::Extern, name.clone(), current_location.clone()),
        "loadlib" => Token::new(TokenType::LoadLib, name.clone(), current_location.clone()),
        "abstract" => Token::new(TokenType::Abstract, name.clone(), current_location.clone()),
        "unsafe" => Token::new(TokenType::Unsafe, name.clone(), current_location.clone()),
        "safe" => Token::new(TokenType::Safe, name.clone(), current_location.clone()),
        "_" => Token::new(TokenType::Underscore, name.clone(), current_location.clone()),
        _ => Token::new(TokenType::Identifier, name.clone(), current_location.clone()),
    };

    tokens.push(new_token);
    i -= 1;
}

Box<Token>: try_get_last_token(&Vec<Box<Token>>: tokens) {
    i32: catch = 0;
    i32: current_line = self.__curent_parsing_line;
    Token: token = tokens.get(0);
    while token.is_none() {
        current_line -= 1;
        token = self.lines[current_line].get(0);

        catch += 1;
        if catch > 100 {
            break;
        }
    }
    return token.unwrap_or(&Box::new(Token::new_empty())).clone();
}

this: that() => though;

pub class A<B, C is D> -> E, F, G {
    H: I = J;
    K: L(M: N) {
        O
    }
}
struct Color {
    u8: R = 0;
    u8: B = 0;
    u8: G = 0;
    u8: A = 0;

    //#! crumb
    //#! description "A color with red, green, blue, and alpha channels."
    static Color: new(r: u8, g: u8, b: u8, a: u8) {
        Color { R = r, G = g, B = b, A = a }
    }
}

trait Number -> Default, ToString {
    Self: MIN;
    Self: MAX;
    Self: ZERO;

    Self: default();
    string: to_string();

    bool: is_integer();
    bool: is_float();
    bool: is_positive();
    bool: is_negative();
    bool: is_zero();
    bool: is_even();
    bool: is_odd();
    
    T: to<T is Number>();
    static Self: from<T is Number>(T: number);
    
    Self: add(Self: other);
    Self: sub(Self: other);
    Self: mul(Self: other);
    Self: div(Self: other);
    Self: mod(Self: other);
    Self: neg();
    Self: eq(Self: other);
    Self: lt(Self: other);
    Self: gt(Self: other);
    Self: le(Self: other);
    Self: ge(Self: other);
    Self: and(Self: other);
    Self: or(Self: other);
    Self: xor(Self: other);
    Self: not();
    Self: bit_and(Self: other);
    Self: bit_or(Self: other);
    Self: bit_xor(Self: other);
    Self: bit_not();
    Self: bit_shift_left(Self: other);
    Self: bit_shift_right(Self: other);
    Self: bit_count();
    Self: byte_count();
    
    Self: pow(Self: number);
    Self: sqrt();
    Self: abs();
    Self: floor();
    Self: ceil();
    Self: round();
    Self: round(u32: digits);
    Self: neg(); 
    Self: min(Self: other);
    Self: max(Self: other);
    Self: clamp(Self: min, Self: max);
}

// tags
#! version 1.0
struct a {
    #! deprecated 
    #! crumb
    a: b();


    #! deprecated 
    a: v;

    a: v();
}

class b {
    #! deprecated
    a: v;
    a: v();
}

#! version 1.0
class c{}

#! deprecated
enum a {
    a,e,i=0
}

#! deprecated
trait o -> a {
    a: b;
    a: v();
}


// inline
#! allow unused 
#! warn deprecated
#! error no_entrance
#! insert "int main() { return 0; }"
#! C pragma once
#! pragma once


// tags
#! version 1.0
struct a{}
#! version 1.0
class c{}
#! deprecated
enum a {}
#! deprecated
trait o {}
#! deprecated
f: unc();
#! deprecated
v: ar;

#! def ADD(x, y) x + y
#! def RESULT ADD(VERSION, 2) / 1.5


before;
#! ifndef AAA
first_one;
#! elif VERSION >= 0.01 && VERSION <= 5
second_one;
#! else
third_one;
#! endif
after;



#! def H1
#! def H2 0
#! def H3() 0
#! def H4

#! def AAAA H3() + 1

#! ifdef H1
1;
#! endif

#! ifndef H2
2;
#! elifdef H3
3;
#! elifndef H4
4;
#! endif


#! undef VERSION
#! def VERSION "HELLO"

print(VERSION);


use "serde::Serialize";
use "crate::{ast::*, lexer::{self, TokenType}, parser}";

pub struct MacroVariable {
    pub String: name;
    pub String: value;
}
pub struct MacroFunction {
    pub String: name;
    pub Vec<String>: args;
    pub String: body;
}
pub struct MacroHeader {
    pub String: name;
}

pub struct Macros {
    pub Vec<MacroVariable>: variables;
    pub Vec<MacroFunction>: functions;
    pub Vec<MacroHeader: headers;
    
    #! crumb
    pub Macros: new() {
        Macros {
            variables = Self::constants(),
            functions = [],
            headers = []
        }
    }
    pub Vec<MacroVariable>: constants() {
        [
            MacroVariable { name = "TRUE".to_string(), value = "1".to_string() },
            MacroVariable { name = "FALSE".to_string(), value = "0".to_string() },
            MacroVariable { name = "INT_MAX".to_string(), value = "2147483647".to_string() },
            MacroVariable { name = "INT_MIN".to_string(), value = "-2147483648".to_string() },
            MacroVariable { name = "UINT_MAX".to_string(), value = "4294967295".to_string() },
            MacroVariable { name = "VERSION".to_string(), value = env("CARGO_PKG_VERSION").split(".").take(2).collect<Vec<&str>>().join(".").to_string() },
        ]
    }
    pub void: add_variable(String: name, String: value) {
        self.variables.push(MacroVariable { name = name, value = value });
    }
    pub void: add_function(String: name, Vec<String>: args, String: body) {
        self.functions.push(MacroFunction { name = name, args = args, body = body });
    }
    pub void: add_header(String: name) {
        self.headers.push(MacroHeader { name = name });
    }
    pub Option<&MacroVariable>: get_variable(&str: name) {
        self.variables.iter().find(var => var.name == name)
    }
    pub Option<&MacroFunction>: get_function(&str: name) {
        self.functions.iter().find(func => func.name == name)
    }
    pub Option<&MacroHeader>: get_header(&str: name) {
        self.headers.iter().find(header => header.name == name)
    }
    pub void: remove_variable(&str: name) {
        self.variables.retain(var => var.name != name);
    }
    pub void: remove_function(&str: name) {
        self.functions.retain(func => func.name != name);
    }
    pub void: remove_header(&str: name) {
        self.headers.retain(header => header.name != name);
    }
    pub bool: has_variable(&str: name) {
        self.get_variable(name).is_some()
    }
    pub bool: has_function(&str: name) {
        self.get_function(name).is_some()
    }
    pub bool: has_header(&str: name) {
        self.get_header(name).is_some()
    }
    pub void: clear() {
        self.variables.clear();
        self.functions.clear();
        self.headers.clear();
    }
    pub bool: is_empty() {
        self.variables.is_empty() && self.functions.is_empty() && self.headers.is_empty()
    }
    pub usize: len() {
        self.variables.len() + self.functions.len() + self.headers.len()
    }
    pub bool: valid_name(&str: name) {
        (name.chars().nth(0).unwrap_or('0').is_alphabetic() || name.chars().nth(0).unwrap_or('0') == '_') && name.chars().all(c => c.is_alphanumeric() || c == '_')
    }
    
    pub Result<bool, String>: parse_if_directive(String: message) {
        Vec<&str>: parts = message.split_whitespace().collect();
        if parts.len() < 2 {
            return Err("Invalid directive".to_string());
        }

        String: condition = parts.skip(1).join(" ");
        auto: value = self.parse_value(condition);

        if value.is_err() {
            return Err("Error parsing condition".to_string());
        }

        auto: result = value.unwrap();
        if result == "true" || result == "1" {
            return Ok(true);
        } else if result == "false" || result == "0" {
            return Ok(false);
        } else {
            return Err("Invalid boolean value".to_string())
        }
    }

    pub Result<bool, String>: parse_if_define_directive(String: message) {
        Vec<&str>: parts = message.split_whitespace().collect();
        if parts.len() != 2 {
            return Err("Invalid `define` directive, expected a name: `#! ifdef NAME ...`".to_string());
        }

        auto: name = parts[1];
        if self.has_header(name) || self.has_function(name) || self.has_variable(name) {
            return Ok(true);
        } else {
            return Ok(false);
        }
    }

    pub Result<OK, String>: parse_define_directive(String: message) {
        Vec<&str>: parts = message.split_whitespace().collect();
        if parts.len() < 2 {
            return Err("Invalid `define` directive, expected at least a name: `#! def NAME ...`".to_string());
        }
        
        Vec<&str>: name = parts[1].chars().take_while(c => c != &'(').collect<String>();
        if Macros::valid_name(&name) == false {
            return Err("Invalid macro name, only alphanumeric characters and underscores are allowed".to_string());
        }

        if parts.len() == 2 {
            // defining header
            if self.has_header(&name) {
                return Err(format("Macro `{}` is already defined", name));
            }
            self.add_header(name.to_string());
        } else if parts[1].contains("(") {
            // define function
            if self.has_function(&name) {
                return Err(format("Macro function `{}` is already defined", name));
            }
            auto: chars = message.chars().skip_while(x => *x != '(').into_iter();
            chars.next(); // skip '('
            auto: args = [];
            auto: current_arg = "".to_string();
            auto: in_arg = false;
            auto: j = 1;
            while c == chars.next() {
                j += 1;
                if c == ')' {
                    if !current_arg.is_empty() {
                        args.push(current_arg.to_string());
                    }
                    break;
                } else if c.is_whitespace() {
                    j += 1;
                    continue;
                } else if c == ',' {
                    if in_arg {
                        args.push(current_arg.to_string());
                        current_arg = "".to_string();
                        in_arg = false;
                    } else {
                        return Err("Unexpected comma in macro function definition".to_string());
                    }
                } else if (c.is_alphabetic() || c == '_') && !in_arg {
                    current_arg.push(c);
                    in_arg = true;
                } else if (c.is_alphabetic() || c.is_numeric() || c == '_') && in_arg {
                    current_arg.push(c);
                } else {
                    return Err(format("Invalid character `{}` in macro function definition", c));
                }
            }
            auto: position = message.chars().position(x => x == '(').unwrap_or(0);
            auto: body = message.take(position + j).trim().to_string();
            if body.is_empty() {
                return Err("Macro function body cannot be empty".to_string());
            }
            self.add_function(name.to_string(), args, body);
        } else {
            // defining variable
            if self.has_variable(&name) {
                return Err(format("Macro variable `{}` is already defined", name));
            }
            auto: parse_msg = parts.skip(2).join(" ");
            match self.parse_value(parse_msg) {
                Ok => self.add_variable(name.to_string(), value),
                Err => return Err(e)
            }
        }

        return Ok()
    }

    pub Result<OK, String>: parse_undefine_directive(String: message) {
        Vec<&str>: parts = message.split_whitespace().collect();

        if parts.len() != 2 {
            return Err("Invalid `define` directive, expected a name: `#! undef NAME`".to_string());
        }
        
        if Macros::valid_name(parts[1]) == false {
            return Err("Invalid macro name, only alphanumeric characters and underscores are allowed".to_string());
        }

        if self.has_variable(parts[1]) {
            self.remove_variable(parts[1]);
        } else if self.has_function(parts[1]) {
            self.remove_function(parts[1]);
        } else if self.has_header(parts[1]) {
            self.remove_header(parts[1]);
        } else {
            return Err(format("Macro `{}` is not defined", parts[1]));
        }
        return Ok();
    }

    pub Result<ASTNode, String>: string_to_node(&String: message) {
        (tokens, error_handling, OK): tuple = lexer::lex(message, None, None);
        if error_handling.has_errors() {
            return Err("Error lexing macro string".to_string());
        }
        (ast, output): tuple = parser::parse(tokens, &message, None);
        if output.has_errors() {
            return Err("Error parsing macro string".to_string());
        }
        if ast.len() != 1 {
            return Err("Macro body should return 1 end node".to_string());
        }
        Ok(ast[0].clone())
    }

    pub Result<String, String>: parse_value(String: message) {
        auto: node = self.string_to_node(&message);
        if node.is_err() {
            return Err("Error parsing value".to_string());
        }
        auto: node = node.unwrap();
        self.evaluate_node(&node)
    }

    pub Result<String, String>: evaluate_node(&ASTNode: node) {
        match &node.node.as_ref() {
            NodeType::Identifier => {
                match self.get_variable(&val.value) {
                    Some => return Ok(var.value.clone()),
                    None => return Err(format("Variable `{}` not defined", val.value))
                }
            }
            NodeType::Constant => {
                return Ok(val.value.value.clone())
            }
            NodeType::Operator => {
                match val.operator.token_type {
                    TokenType::Plus => {
                        auto: l = self.evaluate_node(&val.left);
                        auto: r = self.evaluate_node(&val.right);
                        if Ok(l_val) == l.parse<f32>() {
                            if Ok(r_val) == r.parse<f32>() {
                                return Ok((l_val + r_val).to_string());
                            }
                        }
                        return Ok(l + &r)
                    }
                    TokenType::Dash => {
                        auto: l = self.evaluate_node(&val.left).parse<f32>();
                        auto: r = self.evaluate_node(&val.right).parse<f32>();
                        if l.is_ok() && r.is_ok() {
                            return Ok((l.unwrap() - r.unwrap()).to_string());
                        }
                        return Err("Error evaluating subtraction".to_string())
                    }
                    TokenType::Star => {
                        auto: l = self.evaluate_node(&val.left).parse<f32>();
                        auto: r = self.evaluate_node(&val.right).parse<f32>();
                        if l.is_ok() && r.is_ok() {
                            return Ok((l.unwrap() * r.unwrap()).to_string());
                        }
                        return Err("Error evaluating multiplication".to_string())
                    }
                    TokenType::Slash => {
                        auto: l = self.evaluate_node(&val.left).parse<f32>();
                        auto: r = self.evaluate_node(&val.right).parse<f32>();
                        if l.is_ok() && r.is_ok() && r.clone().unwrap() != 0.0 {
                            return Ok((l.unwrap() / r.unwrap()).to_string());
                        }
                        return Err("Error evaluating division or division by zero".to_string())
                    }
                    TokenType::Equal => {
                        auto: l = self.evaluate_node(&val.left);
                        auto: r = self.evaluate_node(&val.right);
                        if l == r {
                            return Ok("true".to_string());
                        }
                        return Ok("false".to_string())
                    }
                    TokenType::NotEqual => {
                        auto: l = self.evaluate_node(&val.left);
                        auto: r = self.evaluate_node(&val.right);
                        if l != r {
                            return Ok("true".to_string());
                        }
                        return Ok("false".to_string())
                    }
                    TokenType::GreaterThan => {
                        auto: l = self.evaluate_node(&val.left).parse<f32>();
                        auto: r = self.evaluate_node(&val.right).parse<f32>();
                        if l.is_ok() && r.is_ok() {
                            return Ok((l.unwrap() > r.unwrap()).to_string());
                        }
                        return Err("Error evaluating greater than comparison".to_string())
                    }
                    TokenType::LessThan => {
                        auto: l = self.evaluate_node(&val.left).parse<f32>();
                        auto: r = self.evaluate_node(&val.right).parse<f32>();
                        if l.is_ok() && r.is_ok() {
                            return Ok((l.unwrap() < r.unwrap()).to_string());
                        }
                        return Err("Error evaluating less than comparison".to_string())
                    }
                    TokenType::GreaterThanOrEqual => {
                        auto: l = self.evaluate_node(&val.left).parse<f32>();
                        auto: r = self.evaluate_node(&val.right).parse<f32>();
                        if l.is_ok() && r.is_ok() {
                            return Ok((l.unwrap() >= r.unwrap()).to_string());
                        }
                        return Err("Error evaluating greater than or equal comparison".to_string())
                    }
                    TokenType::LessThanOrEqual => {
                        auto: l = self.evaluate_node(&val.left).parse<f32>();
                        auto: r = self.evaluate_node(&val.right).parse<f32>();
                        if l.is_ok() && r.is_ok() {
                            return Ok((l.unwrap() <= r.unwrap()).to_string());
                        }
                        return Err("Error evaluating less than or equal comparison".to_string())
                    }
                    TokenType::And => {
                        auto: l = self.evaluate_node(&val.left);
                        auto: r = self.evaluate_node(&val.right);
                        if l == "true" && r == "true" {
                            return Ok("true".to_string());
                        }
                        return Ok("false".to_string())
                    }
                    TokenType::Or => {
                        auto: l = self.evaluate_node(&val.left);
                        auto: r = self.evaluate_node(&val.right);
                        if l == "true" || r == "true" {
                            return Ok("true".to_string());
                        }
                        return Ok("false".to_string())
                    }
                    TokenType::Not => {
                        auto: val = self.evaluate_node(&val.left);
                        if val == "true" {
                            return Ok("false".to_string());
                        } else if val == "false" {
                            return Ok("true".to_string());
                        }
                        return Err("Error evaluating logical NOT operation".to_string())
                    }
                    _ => {
                        return Err("Unsupported operator for macro evaluation".to_string())
                    }
                } 
            }
            NodeType::FunctionCall => {
                if !self.has_function(&val.name.value) {
                    return Err(format("Macro function `{}` not defined", val.name.value));
                }
                auto: func = self.get_function(&val.name.value).unwrap().clone();
                auto: args = val.parameters.parameters.clone();
                auto: evaluated_args = args.iter().map(arg => self.evaluate_node(arg)).collect<Result<Vec<String>, String>>();
                if evaluated_args.is_err() {
                    return Err("Error evaluating function arguments".to_string());
                }
                
                return self.macro_function(evaluated_args.unwrap(), &func)
            }
            NodeType::ScopedExpression => {
                auto: result = String::new();
                if val.scope.len() != 1 {
                    return Err("No scoping for macro evaluation, expected exactly one identifier while calling".to_string());
                }
                for ident in &val.scope {
                    auto: expr = *ident.expression.clone();
                    auto: evaluated = self.evaluate_node(&expr);
                    result.push_str(&evaluated);
                }
                return Ok(result)
            }
            _ => {
                return Err(format("Unsupported node type for macro evaluation, supports: identifiers, operators, function calls, literals. Instead got: `{}`", node.node.to_string()))
            }
        }
    }

    pub Result<String, String>: macro_function(Vec<String>: args, &MacroFunction: func) {
        if args.len() != func.args.len() {
            return Err("Function argument count mismatch".to_string())
        }
        
        for arg in &func.args {
            if self.has_variable(arg) {
                return Err("Function argument name conflicts with existing variable".to_string());
            }
        }

        for i in func.args.iter().enumerate() {
            self.add_variable(arg.clone(), args[i].clone());
        }

        auto: body = func.body.clone();
        auto: node = self.string_to_node(&body);
        if node.is_err() {
            return Err("Error parsing function body".to_string());
        }

        auto: evaluated_node = self.evaluate_node(&node.unwrap());

        for arg in &func.args {
            self.remove_variable(arg);
        }

        evaluated_node
    }
}

pub String: format(String: message, (ToString): params ...) {
    u8: chars = message.to_chars();
    bool: in_escape = false;
    String: result = "";
    u32: params_index = 0;
    for c in chars {
        if in_escape {
            match c {
                'n' => result.push('\n'),
                't' => result.push('\t'),
                'r' => result.push('\r'),
                '\'' => result.push('\''),
                '\\' => result.push('\\'),
                '0' => result.push('\0'),
                '%' => result.push('%'),
                _ => break
            }
            continue;
        }

        if c == '\\' {
            in_escape = true;
        } else if c == '%' {
            in_escape = false;
            result.push_string(params[params_index].to_string());
            params_index += 1;
        } else {
            in_escape = false;
            result.push(c);
        }
    }

    result
}


trait Default {
    Self: default();
}

trait ToString {
    String: to_string();
}

struct Color -> Default, ToString {
    u8: r = 0;
    u8: g = 0;
    u8: b = 0;

    #! crumb
    pub static Color: new(u8: _r, u8: _g, u8: _b) {
        Color { r = _r, g = _g, b = _b }
    } 

    #! crumb
    pub static Color: default() {
        new(0, 0, 0)
    }

    pub String: to_string() {
        format("{Color R = %, G = %, B = %}", r, g, b);
    }
}

memcpy(data as char*);
size += 1;