x: i32 = (5 + 3) * -(-2);
value = (1, "test", true).b;
auto: result = array[0][1] + matrix[2][3];
point: vec = vec { x = 10, y = array[1][2] };
str: message = func<type>("arg1", (nested[1][0], "test").a);
bool: check = (x > 0 ? 1 : 2) == (tuple[0].c);
i32: value = { x: i32 = 10; y = -x * 3; return y; };
tuple: data = (3, 4, vec { a = 1, b = 2 }).c;
x = -((5 + array[0][2]) * ~(tuple[1].b));
result = func(array[1][2], (nested { x = 1 }).x, true);
auto: expr = (2 * (3 + 5)).a + array[3][4];
obj: init = vec { a = (x, y, z).c, b = array[2][1] };
tuple: t = (5, nested::func(x, y).z, "test");
matrix[1][0] = (10 + nested[0][0]).a;
str: complex = (nested::call<type1, type2>(arg1, arg2)[0]).a + "suffix";
value = (nested::func().a + (5 * 3)).b;
array[1][2] = (10, 20, 30).c + matrix[2][3];
result = { x = 5; y = -x + 2; return y * 3; };
tuple: pair = (array[0][1], "value").a + 1;
matrix[0][1] = vec { a = (1, 2).b, b = 3 * 2 };
bool: valid = (x ? y : z).a && array[2][3];
x = func(array[1][2]).b - (nested[3][4]).a;
tuple = (vec { x = 1, y = 2 }.x, matrix[1][0]).b;
str: output = func<type>("test").a + nested::call().b;
array[0][2] = ((5 * 2) - tuple[1].b).c;
matrix[2][3] = array[(5 + 3)].a * vec { x = 1 }.x;
result = (nested::func<type>(arg1, arg2).a + array[0][1]).b;
value = -(-(tuple[1].a) * (nested[2][3]).b);
bool: check = vec { x = 10, y = 20 }.x == (5, true).a;
str: text = "prefix" + (nested[0][1].a * 3).b;
i32: num = func<type>(5 + (3 * 2)).a - array[1][2];
obj: data = vec { a = (1, 2).a + matrix[0][1], b = 10 };
result = (5, 6, vec { x = 2, y = 4 }.x).c * 2;
tuple[0].a = nested::call<type>(arg1).a + array[1][1];
array[1][2] = vec { a = 10, b = (2, 4).a }.b - matrix[3][0];
nested::func()[1][2] = (5 + array[0][1].a).c;
value = (10, vec { x = 1, y = 2 }).b + nested[1][2];
bool: flag = (tuple[1].b > (array[1][2]).c) && nested[2][3];
auto: expr = func<type>("test").a * (matrix[0][0]).b;
array[(5 + 3)].b = nested::func<type>().a + (10, "text").c;
tuple = (nested[0][1].a, vec { x = 1, y = 2 }.y).b;
x = (5 + (nested::func<type>(arg1).a * array[0][2])).c;
obj: vec = vec { x = (1, 2).b + nested::call().a, y = 20 };
bool: comparison = ((10, 20).b == matrix[1][0]) && array[1][1];
matrix[1][1] = vec { a = (5, "text").c, b = array[2][3] };
tuple: data = (nested::func()[0][1].a + 2, vec { a = 1 }.a).c;
str: message = nested::call<type>("arg").b + array[0][0];
nested[0][1] = (10 + vec { x = 1, y = 2 }.y).a;
i32: result = func<type>(array[1][2]).b * nested[3][4];
matrix[0][1] = (vec { a = (3, 4).b, b = 10 }.a + array[0][1]).c;